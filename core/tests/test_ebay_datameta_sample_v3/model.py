# This file is generated by DataMetaDOM. Do not edit manually!
# package test_ebay_datameta_sample_v3

import re

from ebay_datameta_core.base import Verifiable, DateTime, Migrator
from ebay_datameta_core.canned_re import CannedRe

# noinspection PyCompatibility
from enum import Enum

# package test_ebay_datameta_sample_v3


# ****************** EmbeddedType ***************
class EmbeddedType(Verifiable):
    VERSION = "3.0.0"
    

    def __init__(self):
        self.__intCode = None
        self.__txtCode = None
        self.__embo = None

    def getVersion(self):
        return self.__class__.VERSION


    def getIntCode(self):
        return self.__intCode

    def setIntCode(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"intCode\" on the class EmbeddedType.")
        self.__intCode = val

    def getTxtCode(self):
        return self.__txtCode

    def setTxtCode(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"txtCode\" on the class EmbeddedType.")
        self.__txtCode = val

    def getEmbo(self):
        return self.__embo

    def setEmbo(self, val):
        self.__embo = val


    def __eq__(self, other):
        if not isinstance(other, type(self)): raise AttributeError("Attempt to compare an instance of %s to an instance of %s" % (self.__class__, other.__class__))
        return (self.__intCode) == (other._EmbeddedType__intCode)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        return (hash(self.__intCode) ^ hash((self.__intCode)))

    def verify(self):
        missingFields = []
        if(self.__intCode is None): missingFields.append("intCode");
        if(self.__txtCode is None): missingFields.append("txtCode");
        if(len(missingFields) != 0): raise AttributeError("EmbeddedType: required fields not set: %s" % ", ".join(missingFields))
        

        if(self.__embo is not None): self.__embo.verify()
        return

# -------------- END of EmbeddedType --------------

# package test_ebay_datameta_sample_v3


# ****************** Embodiment ***************
class Embodiment(Verifiable):
    VERSION = "3.0.0"
    

    def __init__(self):
        self.__id = None
        self.__inclusivement = None
        self.__mbe = None

    def getVersion(self):
        return self.__class__.VERSION


    def getId(self):
        return self.__id

    def setId(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"id\" on the class Embodiment.")
        self.__id = val

    def getInclusivement(self):
        return self.__inclusivement

    def setInclusivement(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"inclusivement\" on the class Embodiment.")
        self.__inclusivement = val

    def getMbe(self):
        return self.__mbe

    def setMbe(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"mbe\" on the class Embodiment.")
        self.__mbe = val


    def __eq__(self, other):
        if not isinstance(other, type(self)): raise AttributeError("Attempt to compare an instance of %s to an instance of %s" % (self.__class__, other.__class__))
        return (self.__id) == (other._Embodiment__id)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        return (hash(self.__id) ^ hash((self.__id)))

    def verify(self):
        missingFields = []
        if(self.__id is None): missingFields.append("id");
        if(self.__inclusivement is None): missingFields.append("inclusivement");
        if(self.__mbe is None): missingFields.append("mbe");
        if(len(missingFields) != 0): raise AttributeError("Embodiment: required fields not set: %s" % ", ".join(missingFields))
        

        self.__mbe.verify()
        return

# -------------- END of Embodiment --------------

# package test_ebay_datameta_sample_v3


# ****************** IdLess ***************
class IdLess(Verifiable):
    VERSION = "3.0.0"
    

    def __init__(self):
        self.__count = None
        self.__name = None
        self.__when = None

    def getVersion(self):
        return self.__class__.VERSION


    def getCount(self):
        return self.__count

    def setCount(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"count\" on the class IdLess.")
        self.__count = val

    def getName(self):
        return self.__name

    def setName(self, val):
        self.__name = val

    def getWhen(self):
        return self.__when

    def setWhen(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"when\" on the class IdLess.")
        self.__when = val


    def __eq__(self, other):
        if not isinstance(other, type(self)): raise AttributeError("Attempt to compare an instance of %s to an instance of %s" % (self.__class__, other.__class__))
        return (self.__count, self.__name, self.__when) == (other._IdLess__count, other._IdLess__name, other._IdLess__when)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        return (hash(self.__count) ^ hash(self.__name) ^ hash(self.__when) ^ hash((self.__count, self.__name, self.__when)))

    def verify(self):
        missingFields = []
        if(self.__count is None): missingFields.append("count");
        if(self.__when is None): missingFields.append("when");
        if(len(missingFields) != 0): raise AttributeError("IdLess: required fields not set: %s" % ", ".join(missingFields))
        

        return

# -------------- END of IdLess --------------

# package test_ebay_datameta_sample_v3


# ****************** MultiFieldId ***************
class MultiFieldId(Verifiable):
    VERSION = "3.0.0"
    

    def __init__(self):
        self.__a = None
        self.__b = None
        self.__c = None
        self.__timing = None
        self.__text = None

    def getVersion(self):
        return self.__class__.VERSION


    def getA(self):
        return self.__a

    def setA(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"a\" on the class MultiFieldId.")
        self.__a = val

    def getB(self):
        return self.__b

    def setB(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"b\" on the class MultiFieldId.")
        self.__b = val

    def getC(self):
        return self.__c

    def setC(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"c\" on the class MultiFieldId.")
        self.__c = val

    def getTiming(self):
        return self.__timing

    def setTiming(self, val):
        self.__timing = val

    def getText(self):
        return self.__text

    def setText(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"text\" on the class MultiFieldId.")
        self.__text = val


    def __eq__(self, other):
        if not isinstance(other, type(self)): raise AttributeError("Attempt to compare an instance of %s to an instance of %s" % (self.__class__, other.__class__))
        return (self.__a, self.__b, self.__c) == (other._MultiFieldId__a, other._MultiFieldId__b, other._MultiFieldId__c)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        return (hash(self.__a) ^ hash(self.__b) ^ hash(self.__c) ^ hash((self.__a, self.__b, self.__c)))

    def verify(self):
        missingFields = []
        if(self.__a is None): missingFields.append("a");
        if(self.__b is None): missingFields.append("b");
        if(self.__c is None): missingFields.append("c");
        if(self.__text is None): missingFields.append("text");
        if(len(missingFields) != 0): raise AttributeError("MultiFieldId: required fields not set: %s" % ", ".join(missingFields))
        

        return

# -------------- END of MultiFieldId --------------

# package test_ebay_datameta_sample_v3


# ****************** WithoutIdentity ***************
class WithoutIdentity(Verifiable):
    VERSION = "3.0.0"
    

    def __init__(self):
        self.__a = None
        self.__b = None

    def getVersion(self):
        return self.__class__.VERSION


    def getA(self):
        return self.__a

    def setA(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"a\" on the class WithoutIdentity.")
        self.__a = val

    def getB(self):
        return self.__b

    def setB(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"b\" on the class WithoutIdentity.")
        self.__b = val


    def __eq__(self, other):
        if not isinstance(other, type(self)): raise AttributeError("Attempt to compare an instance of %s to an instance of %s" % (self.__class__, other.__class__))
        return (self.__a, self.__b) == (other._WithoutIdentity__a, other._WithoutIdentity__b)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        return (hash(self.__a) ^ hash(self.__b) ^ hash((self.__a, self.__b)))

    def verify(self):
        missingFields = []
        if(self.__a is None): missingFields.append("a");
        if(self.__b is None): missingFields.append("b");
        if(len(missingFields) != 0): raise AttributeError("WithoutIdentity: required fields not set: %s" % ", ".join(missingFields))
        

        return

# -------------- END of WithoutIdentity --------------

# package test_ebay_datameta_sample_v3


# ****************** KitchenSink ***************
class KitchenSink(Verifiable):
    VERSION = "3.0.0"
    REGEX___1___ = re.compile("^(\\d{5,5})(?:[- ](\\d{4,4}))?$") # homeZip, workZip
    REGEX___2___ = re.compile("^(\\w+),[ ]*(\\w+)") # lastFirstName

    def __init__(self):
        self.__id = None
        self.__context = None
        self.__strings = None
        self.__embeds = None
        self.__ints = None
        self.__times = None
        self.__idLessNess = None
        self.__strToInt = None
        self.__longToEmb = None
        self.__embToString = None
        self.__embToEmb = None
        self.__name = None
        self.__code = None
        self.__color = None
        self.__type = None
        self.__choices = None
        self.__weights = None
        self.__heights = None
        self.__length = None
        self.__bearing = None
        self.__frequency = None
        self.__amplitude = None
        self.__weight = None
        self.__diameter = None
        self.__radius = None
        self.__temperature = None
        self.__isRequired = None
        self.__isMeasurable = None
        self.__comments = None
        self.__created = None
        self.__altered = None
        self.__salary = None
        self.__homePage = None
        self.__workPage = None
        self.__homeEmail = None
        self.__mobilePhone = None
        self.__homeZip = None
        self.__workZip = None
        self.__lastFirstName = None
        self.__emb = None
        self.__embo = None
        self.__uuidLower = None
        self.__uuidUpper = None
        self.__otherNsRef = None

    def getVersion(self):
        return self.__class__.VERSION


    def getId(self):
        return self.__id

    def setId(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"id\" on the class KitchenSink.")
        self.__id = val

    def getContext(self):
        return self.__context

    def setContext(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"context\" on the class KitchenSink.")
        self.__context = val

    def getStrings(self):
        return self.__strings

    def setStrings(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"strings\" on the class KitchenSink.")
        self.__strings = val

    def getEmbeds(self):
        return self.__embeds

    def setEmbeds(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"embeds\" on the class KitchenSink.")
        self.__embeds = val

    def getInts(self):
        return self.__ints

    def setInts(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"ints\" on the class KitchenSink.")
        self.__ints = val

    def getTimes(self):
        return self.__times

    def setTimes(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"times\" on the class KitchenSink.")
        self.__times = val

    def getIdLessNess(self):
        return self.__idLessNess

    def setIdLessNess(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"idLessNess\" on the class KitchenSink.")
        self.__idLessNess = val

    def getStrToInt(self):
        return self.__strToInt

    def setStrToInt(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"strToInt\" on the class KitchenSink.")
        self.__strToInt = val

    def getLongToEmb(self):
        return self.__longToEmb

    def setLongToEmb(self, val):
        self.__longToEmb = val

    def getEmbToString(self):
        return self.__embToString

    def setEmbToString(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"embToString\" on the class KitchenSink.")
        self.__embToString = val

    def getEmbToEmb(self):
        return self.__embToEmb

    def setEmbToEmb(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"embToEmb\" on the class KitchenSink.")
        self.__embToEmb = val

    def getName(self):
        return self.__name

    def setName(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"name\" on the class KitchenSink.")
        self.__name = val

    def getCode(self):
        return self.__code

    def setCode(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"code\" on the class KitchenSink.")
        self.__code = val

    def getColor(self):
        return self.__color

    def setColor(self, val):
        self.__color = val

    def getType(self):
        return self.__type

    def setType(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"type\" on the class KitchenSink.")
        self.__type = val

    def getChoices(self):
        return self.__choices

    def setChoices(self, val):
        self.__choices = val

    def getWeights(self):
        return self.__weights

    def setWeights(self, val):
        self.__weights = val

    def getHeights(self):
        return self.__heights

    def setHeights(self, val):
        self.__heights = val

    def getLength(self):
        return self.__length

    def setLength(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"length\" on the class KitchenSink.")
        self.__length = val

    def getBearing(self):
        return self.__bearing

    def setBearing(self, val):
        self.__bearing = val

    def getFrequency(self):
        return self.__frequency

    def setFrequency(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"frequency\" on the class KitchenSink.")
        self.__frequency = val

    def getAmplitude(self):
        return self.__amplitude

    def setAmplitude(self, val):
        self.__amplitude = val

    def getWeight(self):
        return self.__weight

    def setWeight(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"weight\" on the class KitchenSink.")
        self.__weight = val

    def getDiameter(self):
        return self.__diameter

    def setDiameter(self, val):
        self.__diameter = val

    def getRadius(self):
        return self.__radius

    def setRadius(self, val):
        self.__radius = val

    def getTemperature(self):
        return self.__temperature

    def setTemperature(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"temperature\" on the class KitchenSink.")
        self.__temperature = val

    def getIsRequired(self):
        return self.__isRequired

    def setIsRequired(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"isRequired\" on the class KitchenSink.")
        self.__isRequired = val

    def getIsMeasurable(self):
        return self.__isMeasurable

    def setIsMeasurable(self, val):
        self.__isMeasurable = val

    def getComments(self):
        return self.__comments

    def setComments(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"comments\" on the class KitchenSink.")
        self.__comments = val

    def getCreated(self):
        return self.__created

    def setCreated(self, val):
        self.__created = val

    def getAltered(self):
        return self.__altered

    def setAltered(self, val):
        self.__altered = val

    def getSalary(self):
        return self.__salary

    def setSalary(self, val):
        self.__salary = val

    def getHomePage(self):
        return self.__homePage

    def setHomePage(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"homePage\" on the class KitchenSink.")
        self.__homePage = val

    def getWorkPage(self):
        return self.__workPage

    def setWorkPage(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"workPage\" on the class KitchenSink.")
        self.__workPage = val

    def getHomeEmail(self):
        return self.__homeEmail

    def setHomeEmail(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"homeEmail\" on the class KitchenSink.")
        self.__homeEmail = val

    def getUuidLower(self):
        return self.__uuidLower

    def setUuidLower(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"uuidLower\" on the class KitchenSink.")
        self.__uuidLower = val

    def getUuidUpper(self):
        return self.__uuidUpper

    def setUuidUpper(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"uuidUpper\" on the class KitchenSink.")
        self.__uuidUpper = val

    def getMobilePhone(self):
        return self.__mobilePhone

    def setMobilePhone(self, val):
        self.__mobilePhone = val

    def getHomeZip(self):
        return self.__homeZip

    def setHomeZip(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"homeZip\" on the class KitchenSink.")
        self.__homeZip = val

    def getWorkZip(self):
        return self.__workZip

    def setWorkZip(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"workZip\" on the class KitchenSink.")
        self.__workZip = val

    def getLastFirstName(self):
        return self.__lastFirstName

    def setLastFirstName(self, val):
        self.__lastFirstName = val

    def getEmb(self):
        return self.__emb

    def setEmb(self, val):
        self.__emb = val

    def getEmbo(self):
        return self.__embo

    def setEmbo(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"embo\" on the class KitchenSink.")
        self.__embo = val

    def getOtherNsRef(self):
        return self.__otherNsRef

    def setOtherNsRef(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"otherNsRef\" on the class KitchenSink.")
        self.__otherNsRef = val


    def __eq__(self, other):
        if not isinstance(other, type(self)): raise AttributeError("Attempt to compare an instance of %s to an instance of %s" % (self.__class__, other.__class__))
        return (self.__id, self.__temperature) == (other._KitchenSink__id, other._KitchenSink__temperature)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        return (hash(self.__id) ^ hash(self.__temperature) ^ hash((self.__id, self.__temperature)))

    def verify(self):
        missingFields = []
        if(self.__id is None): missingFields.append("id");
        if(self.__context is None): missingFields.append("context");
        if(self.__strings is None): missingFields.append("strings");
        if(self.__embeds is None): missingFields.append("embeds");
        if(self.__ints is None): missingFields.append("ints");
        if(self.__times is None): missingFields.append("times");
        if(self.__idLessNess is None): missingFields.append("idLessNess");
        if(self.__strToInt is None): missingFields.append("strToInt");
        if(self.__embToString is None): missingFields.append("embToString");
        if(self.__embToEmb is None): missingFields.append("embToEmb");
        if(self.__name is None): missingFields.append("name");
        if(self.__code is None): missingFields.append("code");
        if(self.__type is None): missingFields.append("type");
        if(self.__length is None): missingFields.append("length");
        if(self.__frequency is None): missingFields.append("frequency");
        if(self.__weight is None): missingFields.append("weight");
        if(self.__temperature is None): missingFields.append("temperature");
        if(self.__isRequired is None): missingFields.append("isRequired");
        if(self.__comments is None): missingFields.append("comments");
        if(self.__homePage is None): missingFields.append("homePage");
        if(self.__workPage is None): missingFields.append("workPage");
        if(self.__homeEmail is None): missingFields.append("homeEmail");
        if(self.__uuidLower is None): missingFields.append("uuidLower");
        if(self.__uuidUpper is None): missingFields.append("uuidUpper");
        if(self.__homeZip is None): missingFields.append("homeZip");
        if(self.__workZip is None): missingFields.append("workZip");
        if(self.__embo is None): missingFields.append("embo");
        if(self.__otherNsRef is None): missingFields.append("otherNsRef");
        if(len(missingFields) != 0): raise AttributeError("KitchenSink: required fields not set: %s" % ", ".join(missingFields))
        
        if(CannedRe.CANNED_RES["email"].match(self.__homeEmail) is None):
            raise AttributeError("Property \"homeEmail\" == {{%s}} didn't match canned expression \"email\"" % self.__homeEmail )

        if(CannedRe.CANNED_RES["uuid"].match(self.__uuidLower) is None):
            raise AttributeError("Property \"uuidLower\" == {{%s}} didn't match canned expression \"uuid\"" % self.__uuidLower )

        if(CannedRe.CANNED_RES["UUID"].match(self.__uuidUpper) is None):
            raise AttributeError("Property \"uuidUpper\" == {{%s}} didn't match canned expression \"UUID\"" % self.__uuidUpper )

        if(self.__mobilePhone is not None and CannedRe.CANNED_RES["phone"].match(self.__mobilePhone) is None):
            raise AttributeError("Property \"mobilePhone\" == {{%s}} didn't match canned expression \"phone\"" % self.__mobilePhone )

        if(KitchenSink.REGEX___1___.match(self.__homeZip) is None):
            raise AttributeError("Property \"homeZip\" == {{%s}} didn't match custom expression {{%s}}" %(self.__homeZip, KitchenSink.REGEX___1___))

        if(KitchenSink.REGEX___1___.match(self.__workZip) is None):
            raise AttributeError("Property \"workZip\" == {{%s}} didn't match custom expression {{%s}}" %(self.__workZip, KitchenSink.REGEX___1___))

        if(self.__lastFirstName is not None and KitchenSink.REGEX___2___.match(self.__lastFirstName) is None):
            raise AttributeError("Property \"lastFirstName\" == {{%s}} didn't match custom expression {{%s}}" %(self.__lastFirstName, KitchenSink.REGEX___2___))

        [v___embeds.verify() for v___embeds in self.__embeds ]
        [v___idLessNess.verify() for v___idLessNess in self.__idLessNess ]
        if(self.__longToEmb is not None):
            for k, v in self.__longToEmb.iteritems(): v.verify()

        for k, v in self.__embToString.iteritems():k.verify(); 

        for k, v in self.__embToEmb.iteritems():k.verify(); v.verify()

        if(self.__emb is not None): self.__emb.verify()
        self.__embo.verify()
        self.__otherNsRef.verify()
        return

# -------------- END of KitchenSink --------------

# package test_ebay_datameta_sample_v3


# ****************** AllOptional ***************
class AllOptional(Verifiable):
    VERSION = "3.0.0"
    

    def __init__(self):
        self.__counter = None
        self.__when = None
        self.__what = None
        self.__weight = None
        self.__distance = None

    def getVersion(self):
        return self.__class__.VERSION


    def getCounter(self):
        return self.__counter

    def setCounter(self, val):
        self.__counter = val

    def getWhen(self):
        return self.__when

    def setWhen(self, val):
        self.__when = val

    def getWhat(self):
        return self.__what

    def setWhat(self, val):
        self.__what = val

    def getWeight(self):
        return self.__weight

    def setWeight(self, val):
        self.__weight = val

    def getDistance(self):
        return self.__distance

    def setDistance(self, val):
        self.__distance = val


    def __eq__(self, other):
        if not isinstance(other, type(self)): raise AttributeError("Attempt to compare an instance of %s to an instance of %s" % (self.__class__, other.__class__))
        return (self.__counter, self.__distance, self.__weight, self.__what, self.__when) == (other._AllOptional__counter, other._AllOptional__distance, other._AllOptional__weight, other._AllOptional__what, other._AllOptional__when)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        return (hash(self.__counter) ^ hash(self.__distance) ^ hash(self.__weight) ^ hash(self.__what) ^ hash(self.__when) ^ hash((self.__counter, self.__distance, self.__weight, self.__what, self.__when)))

    def verify(self):        

        return

# -------------- END of AllOptional --------------

# package test_ebay_datameta_sample_v3


# ****************** AllOptWithMatch ***************
class AllOptWithMatch(Verifiable):
    VERSION = "3.0.0"
    

    def __init__(self):
        self.__counter = None
        self.__when = None
        self.__what = None

    def getVersion(self):
        return self.__class__.VERSION


    def getCounter(self):
        return self.__counter

    def setCounter(self, val):
        self.__counter = val

    def getWhen(self):
        return self.__when

    def setWhen(self, val):
        self.__when = val

    def getWhat(self):
        return self.__what

    def setWhat(self, val):
        self.__what = val


    def __eq__(self, other):
        if not isinstance(other, type(self)): raise AttributeError("Attempt to compare an instance of %s to an instance of %s" % (self.__class__, other.__class__))
        return (self.__counter, self.__what, self.__when) == (other._AllOptWithMatch__counter, other._AllOptWithMatch__what, other._AllOptWithMatch__when)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        return (hash(self.__counter) ^ hash(self.__what) ^ hash(self.__when) ^ hash((self.__counter, self.__what, self.__when)))

    def verify(self):        
        if(self.__what is not None and CannedRe.CANNED_RES["email"].match(self.__what) is None):
            raise AttributeError("Property \"what\" == {{%s}} didn't match canned expression \"email\"" % self.__what )


        return

# -------------- END of AllOptWithMatch --------------

# package test_ebay_datameta_sample_v3


# ****************** AllOptCustMatch ***************
class AllOptCustMatch(Verifiable):
    VERSION = "3.0.0"
    REGEX___1___ = re.compile("^some\\s+stuff$") # what

    def __init__(self):
        self.__counter = None
        self.__when = None
        self.__what = None

    def getVersion(self):
        return self.__class__.VERSION


    def getCounter(self):
        return self.__counter

    def setCounter(self, val):
        self.__counter = val

    def getWhen(self):
        return self.__when

    def setWhen(self, val):
        self.__when = val

    def getWhat(self):
        return self.__what

    def setWhat(self, val):
        self.__what = val


    def __eq__(self, other):
        if not isinstance(other, type(self)): raise AttributeError("Attempt to compare an instance of %s to an instance of %s" % (self.__class__, other.__class__))
        return (self.__counter, self.__what, self.__when) == (other._AllOptCustMatch__counter, other._AllOptCustMatch__what, other._AllOptCustMatch__when)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        return (hash(self.__counter) ^ hash(self.__what) ^ hash(self.__when) ^ hash((self.__counter, self.__what, self.__when)))

    def verify(self):        
        if(self.__what is not None and AllOptCustMatch.REGEX___1___.match(self.__what) is None):
            raise AttributeError("Property \"what\" == {{%s}} didn't match custom expression {{%s}}" %(self.__what, AllOptCustMatch.REGEX___1___))

        return

# -------------- END of AllOptCustMatch --------------

# package test_ebay_datameta_sample_v3


# ****************** AllOptWithObj ***************
class AllOptWithObj(Verifiable):
    VERSION = "3.0.0"
    

    def __init__(self):
        self.__counter = None
        self.__allOpt = None

    def getVersion(self):
        return self.__class__.VERSION


    def getCounter(self):
        return self.__counter

    def setCounter(self, val):
        self.__counter = val

    def getAllOpt(self):
        return self.__allOpt

    def setAllOpt(self, val):
        self.__allOpt = val


    def __eq__(self, other):
        if not isinstance(other, type(self)): raise AttributeError("Attempt to compare an instance of %s to an instance of %s" % (self.__class__, other.__class__))
        return (self.__allOpt, self.__counter) == (other._AllOptWithObj__allOpt, other._AllOptWithObj__counter)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        return (hash(self.__allOpt) ^ hash(self.__counter) ^ hash((self.__allOpt, self.__counter)))

    def verify(self):        

        if(self.__allOpt is not None): self.__allOpt.verify()
        return

# -------------- END of AllOptWithObj --------------

# package test_ebay_datameta_sample_v3


# ****************** ExampleNsRec ***************
class ExampleNsRec(Verifiable):
    VERSION = "3.0.0"
    

    def __init__(self):
        self.__id = None
        self.__name = None
        self.__choices = None

    def getVersion(self):
        return self.__class__.VERSION


    def getId(self):
        return self.__id

    def setId(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"id\" on the class ExampleNsRec.")
        self.__id = val

    def getName(self):
        return self.__name

    def setName(self, val):
        if val is None: raise AttributeError("The \"None\" argument passed to the setter of the required field \"name\" on the class ExampleNsRec.")
        self.__name = val

    def getChoices(self):
        return self.__choices

    def setChoices(self, val):
        self.__choices = val


    def __eq__(self, other):
        if not isinstance(other, type(self)): raise AttributeError("Attempt to compare an instance of %s to an instance of %s" % (self.__class__, other.__class__))
        return (self.__id) == (other._ExampleNsRec__id)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        return (hash(self.__id) ^ hash((self.__id)))

    def verify(self):
        missingFields = []
        if(self.__id is None): missingFields.append("id");
        if(self.__name is None): missingFields.append("name");
        if(len(missingFields) != 0): raise AttributeError("ExampleNsRec: required fields not set: %s" % ", ".join(missingFields))
        

        return

# -------------- END of ExampleNsRec --------------

WordedEnum = Enum("WordedEnum", "Int Long String VarString Bool _Date Time Bitset DateTime")

BaseColor = Enum("BaseColor", "Red Green Blue")

